<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CodeGPT — Local</title>

  <!-- Prism for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

  <style>
    :root { --bg:#0f1115; --panel:#151821; --panel2:#1b2030; --text:#e6e6e6; --muted:#9aa0aa; --border:#2a2f3a; --accent:#6ea8fe; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,Arial;height:100vh;display:grid;grid-template-rows:1fr auto}
    /* Chat area */
    #chat-box{padding:22px;overflow:auto}
    .bubble{max-width:1000px;margin:10px auto;border:1px solid var(--border);border-radius:12px;background:#0b0f18;padding:12px;white-space:pre-wrap}
    .you{background:#0b1220}
    .ai{background:#08101a}
    .label{opacity:.7;margin-bottom:6px;font-size:13px}
    pre{background:#0b0f18!important;border:1px solid var(--border);border-radius:10px;padding:12px;overflow:auto;margin:8px 0 4px}
    .copy-btn{display:inline-block;margin:0 0 8px;padding:6px 8px;border:1px solid var(--border);background:#0b0f18;color:var(--text);border-radius:6px;cursor:pointer}
    /* Composer */
    .composer{border-top:1px solid var(--border);background:var(--panel);padding:14px}
    .wrap{max-width:1000px;margin:0 auto;background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:10px}
    textarea{width:100%;min-height:64px;max-height:60vh;resize:vertical;border:0;background:transparent;color:var(--text);outline:none;font:14px/1.45 monospace;white-space:pre-wrap}
    .controls{display:flex;justify-content:space-between;gap:8px;margin-top:8px}
    .btn{padding:8px 12px;border:1px solid var(--border);border-radius:8px;background:transparent;color:var(--text);cursor:pointer}
    .send{background:#163a22;border-color:#1f4d2c;color:#c6f6d5}
    .max.active{border-color:var(--accent)}
    .wrap.max textarea{height:60vh}
    .error{color:#ffb4b4}
  </style>
</head>
<body>
  <div id="chat-box"></div>

  <div class="composer">
    <div id="wrap" class="wrap">
      <textarea id="userInput" placeholder="Ask about code… (Shift+Enter = newline)"></textarea>
      <div class="controls">
        <div>
          <button id="maxBtn" class="btn max" onclick="toggleMax()">⤢ Maximize</button>
          <button class="btn" onclick="clearInput()">↺ Clear</button>
          <button class="btn" onclick="resetChat()">🗑 Reset Chat</button>
        </div>
        <button class="btn send" onclick="send()">Send ▸</button>
      </div>
    </div>
  </div>

  <!-- Prism -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>

  <script>
    const box = document.getElementById('chat-box');
    const input = document.getElementById('userInput');

    // Helpers
    function escHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}

    function addBubble(role, content, typewriter=true){
      const bubble = document.createElement('div');
      bubble.className = 'bubble ' + (role==='user' ? 'you' : 'ai');

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = role === 'user' ? 'You' : 'AI';
      bubble.appendChild(label);

      // ✅ Append bubble to DOM BEFORE rendering/typing so scrolling never hits null
      box.appendChild(bubble);
      box.scrollTop = box.scrollHeight;

      // Split on fenced blocks
      const regex = /```(\w+)?\n([\s\S]*?)```/g;
      let start = 0, m;
      const parts = [];
      while((m = regex.exec(content)) !== null){
        parts.push({type:'text', text: content.slice(start, m.index)});
        parts.push({type:'code', lang: m[1] || 'plaintext', code: m[2]});
        start = regex.lastIndex;
      }
      parts.push({type:'text', text: content.slice(start)});

      (async function render(){
        for(const p of parts){
          if(p.type === 'text'){
            if(typewriter) {
              await typeInto(bubble, p.text);
            } else {
              const seg = document.createElement('div');
              seg.innerHTML = escHtml(p.text).replace(/\n/g,'<br>');
              bubble.appendChild(seg);
            }
          } else {
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            code.className = 'language-' + p.lang;
            code.textContent = p.code;
            pre.appendChild(code);

            const btn = document.createElement('button');
            btn.className = 'copy-btn';
            btn.textContent = '📋 Copy';
            btn.onclick = () => navigator.clipboard.writeText(p.code);

            bubble.appendChild(pre);
            bubble.appendChild(btn);
            try { Prism.highlightAllUnder(pre); } catch(e) {}
          }
          // always scroll the chat box (not parentElement)
          box.scrollTop = box.scrollHeight;
        }
      })();
    }

    function typeInto(container, text, speed=12){
      return new Promise(resolve=>{
        const seg = document.createElement('div');
        container.appendChild(seg);
        let i=0;
        (function step(){
          if(i < text.length){
            seg.innerHTML += escHtml(text[i]).replace(/\n/g,'<br>');
            i++;
            // ✅ Always use the known scroller
            box.scrollTop = box.scrollHeight;
            setTimeout(step, speed);
          } else resolve();
        })();
      });
    }

    // Actions
    async function send(){
      const msg = input.value; // keep exact formatting; no trim
      if(!msg) return;
      addBubble('user', msg, false);
      input.value = '';

      try{
        const res = await fetch('/chat',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ message: msg })
        });
        const data = await res.json().catch(() => ({}));
        if (!data || data.ok === false) {
          const err = (data && data.error) ? data.error : 'Server error';
          addBubble('ai', '⚠️ ' + err, false);
          return;
        }
        addBubble('ai', data.reply || '(no reply)', true);
      }catch(err){
        addBubble('ai', '⚠️ Error contacting server: ' + err, false);
      }
    }

    async function resetChat(){
      await fetch('/reset', { method:'POST' }).catch(()=>{});
      box.innerHTML = '';
    }

    function clearInput(){ input.value=''; }
    function toggleMax(){
      const w = document.getElementById('wrap');
      const b = document.getElementById('maxBtn');
      w.classList.toggle('max');
      const on = w.classList.contains('max');
      b.classList.toggle('active', on);
      b.textContent = on ? '⤡ Minimize' : '⤢ Maximize';
      input.focus();
    }

    // Enter to send, Shift+Enter newline
    input.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); send(); }
    });
  </script>
</body>
</html>
