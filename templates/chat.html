<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CodeGPT — Local</title>

  <!-- Prism for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

  <style>
    :root { --bg:#0f1115; --panel:#151821; --panel2:#1b2030; --text:#e6e6e6; --muted:#9aa0aa; --border:#2a2f3a; --accent:#6ea8fe; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,Arial;height:100vh;display:grid;grid-template-rows:1fr auto}
    /* Chat area */
    #chat-box{padding:22px;overflow:auto}
    .bubble{max-width:1000px;margin:10px auto;border:1px solid var(--border);border-radius:12px;background:#0b0f18;padding:12px;white-space:pre-wrap}
    .you{background:#0b1220}
    .ai{background:#08101a}
    .label{opacity:.7;margin-bottom:6px;font-size:13px}
    pre{background:#0b0f18!important;border:1px solid var(--border);border-radius:10px;padding:12px;overflow:auto;margin:8px 0 4px}
    .copy-btn{display:inline-block;margin:0 0 8px;padding:6px 8px;border:1px solid var(--border);background:#0b0f18;color:var(--text);border-radius:6px;cursor:pointer}
    /* Composer */
    .composer{border-top:1px solid var(--border);background:var(--panel);padding:14px}
    .wrap{max-width:1000px;margin:0 auto;background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:10px}
    textarea{width:100%;min-height:64px;max-height:60vh;resize:vertical;border:0;background:transparent;color:var(--text);outline:none;font:14px/1.45 monospace;white-space:pre-wrap}
    .controls{display:flex;justify-content:space-between;gap:8px;margin-top:8px;flex-wrap:wrap}
    .btn{padding:8px 12px;border:1px solid var(--border);border-radius:8px;background:transparent;color:var(--text);cursor:pointer}
    .send{background:#163a22;border-color:#1f4d2c;color:#c6f6d5}
    .max.active{border-color:var(--accent)}
    .wrap.max textarea{height:60vh}
    .error{color:#ffb4b4}
    /* Export note (appears only in PDF header) */
    .pdf-header{display:none}
  </style>
</head>
<body>
  <div id="chat-box"></div>

  <div class="composer">
    <div id="wrap" class="wrap">
      <textarea id="userInput" placeholder="Ask about code… (Shift+Enter = newline)"></textarea>
      <div class="controls">
        <div>
          <button id="maxBtn" class="btn max" onclick="toggleMax()">⤢ Maximize</button>
          <button class="btn" onclick="clearInput()">↺ Clear</button>
          <button class="btn" onclick="resetChat()">🗑 Reset Chat</button>
        </div>
        <div>
          <button class="btn" onclick="exportPDF()">🧾 Export PDF</button>
          <button class="btn send" onclick="send()">Send ▸</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Prism (syntax highlighting) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>

  <!-- Marked (Markdown renderer for advanced formatting) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.2/marked.min.js"></script>

  <!-- html2canvas + jsPDF for client-side PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    const box = document.getElementById('chat-box');
    const input = document.getElementById('userInput');

    // Helpers
    function escHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}
    function nowStamp(){
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      // YYYY-MM-DD_HH-MM-SS
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
    }

    function addBubble(role, content, typewriter=true){
      const bubble = document.createElement('div');
      bubble.className = 'bubble ' + (role==='user' ? 'you' : 'ai');

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = role === 'user' ? 'You' : 'AI';
      bubble.appendChild(label);

      // Append bubble to DOM before typing
      box.appendChild(bubble);
      box.scrollTop = box.scrollHeight;

      // Split on fenced code blocks
      const regex = /```(\w+)?\n([\s\S]*?)```/g;
      let start = 0, m;
      const parts = [];
      while((m = regex.exec(content)) !== null){
        parts.push({type:'text', text: content.slice(start, m.index)});
        parts.push({type:'code', lang: m[1] || 'plaintext', code: m[2]});
        start = regex.lastIndex;
      }
      parts.push({type:'text', text: content.slice(start)});

      (async function render(){
        for(const p of parts){
          if(p.type === 'text'){
            if(typewriter) {
              await typeIntoMarkdown(bubble, p.text); // type then convert to markdown
            } else {
              // directly render markdown (no typing)
              const seg = document.createElement('div');
              try {
                seg.innerHTML = marked.parse(p.text);
              } catch(e) {
                seg.innerHTML = escHtml(p.text).replace(/\n/g,'<br>');
              }
              bubble.appendChild(seg);
              try { Prism.highlightAllUnder(seg); } catch(e) {}
            }
          } else {
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            code.className = 'language-' + p.lang;
            code.textContent = p.code; // preserve indentation
            pre.appendChild(code);

            const btn = document.createElement('button');
            btn.className = 'copy-btn';
            btn.textContent = '📋 Copy';
            btn.onclick = () => navigator.clipboard.writeText(p.code);

            bubble.appendChild(pre);
            bubble.appendChild(btn);
            try { Prism.highlightAllUnder(pre); } catch(e) {}
          }
          box.scrollTop = box.scrollHeight;
        }
      })();
    }

    // Types plain text, then converts that segment to Markdown once done (so formatting appears after typing)
    function typeIntoMarkdown(container, text, speed=12){
      return new Promise(resolve=>{
        const seg = document.createElement('div');
        container.appendChild(seg);
        let i=0;
        let buf = '';
        (function step(){
          if(i < text.length){
            const ch = text[i++];
            buf += ch;
            // during typing, show as plain text to avoid breaking HTML tags
            seg.textContent = buf;
            box.scrollTop = box.scrollHeight;
            setTimeout(step, speed);
          } else {
            // when done, convert to Markdown
            try {
              seg.innerHTML = marked.parse(buf);
            } catch(e) {
              seg.innerHTML = escHtml(buf).replace(/\n/g,'<br>');
            }
            try { Prism.highlightAllUnder(seg); } catch(e) {}
            resolve();
          }
        })();
      });
    }

    // Actions
    async function send(){
      const msg = input.value; // keep exact formatting; no trim
      if(!msg) return;
      addBubble('user', msg, false);
      input.value = '';

      try{
        const res = await fetch('/chat',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ message: msg })
        });
        const data = await res.json().catch(() => ({}));
        if (!data || data.ok === false) {
          const err = (data && data.error) ? data.error : 'Server error';
          addBubble('ai', '⚠️ ' + err, false);
          return;
        }
        addBubble('ai', data.reply || '(no reply)', true);
      }catch(err){
        addBubble('ai', '⚠️ Error contacting server: ' + err, false);
      }
    }

    async function resetChat(){
      await fetch('/reset', { method:'POST' }).catch(()=>{});
      box.innerHTML = '';
    }
    function clearInput(){ input.value=''; }
    function toggleMax(){
      const w = document.getElementById('wrap');
      const b = document.getElementById('maxBtn');
      w.classList.toggle('max');
      const on = w.classList.contains('max');
      b.classList.toggle('active', on);
      b.textContent = on ? '⤡ Minimize' : '⤢ Maximize';
      input.focus();
    }

    // Export conversation as PDF (multi-page) with timestamp
    async function exportPDF(){
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('p', 'pt', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = 24;

      // Header with timestamp
      const ts = new Date();
      const header = `CodeGPT Conversation — ${ts.toLocaleString()}`;
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text(header, margin, margin);

      // Render chat as image(s)
      const chatEl = document.getElementById('chat-box');
      // Clone to ensure proper background
      const clone = chatEl.cloneNode(true);
      clone.style.background = '#ffffff';    // white background for PDF
      clone.style.color = '#000000';

      // Wrap clone in a temp container
      const temp = document.createElement('div');
      temp.style.position = 'fixed';
      temp.style.left = '-10000px';
      temp.style.top = '0';
      temp.style.width = (pageWidth - margin*2) + 'px'; // constrain width to page
      temp.appendChild(clone);
      document.body.appendChild(temp);

      // Use html2canvas on the temp container
      const canvas = await html2canvas(clone, {
        scale: 2,          // higher quality
        backgroundColor: '#ffffff',
        useCORS: true
      });
      document.body.removeChild(temp);

      const imgData = canvas.toDataURL('image/png');
      const imgWidth = pageWidth - margin*2;
      const imgHeight = canvas.height * imgWidth / canvas.width;

      let y = margin + 18; // leave space for header
      let heightLeft = imgHeight;

      pdf.addImage(imgData, 'PNG', margin, y, imgWidth, imgHeight);
      heightLeft -= (pageHeight - y - margin);

      while (heightLeft > 0) {
        pdf.addPage();
        y = margin;
        pdf.text(header, margin, y); // header on each page
        y += 18;
        const position = imgHeight - heightLeft;
        pdf.addImage(imgData, 'PNG', margin, y, imgWidth, imgHeight);
        heightLeft -= (pageHeight - y - margin);
      }

      const filename = `CodeGPT_Conversation_${nowStamp()}.pdf`;
      pdf.save(filename);
    }

    // Enter to send, Shift+Enter newline
    input.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); send(); }
    });
  </script>
</body>
</html>
