<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CodeGPT â€” Local</title>

  <!-- Prism for highlighting (optional) -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

  <style>
    :root { --bg:#0f1115; --panel:#151821; --muted:#9aa0aa; --accent:#6ea8fe; --text:#e6e6e6; --border:#2a2f3a; --panel2:#1b2030; }
    *{box-sizing:border-box}body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Arial;background:var(--bg);color:var(--text);height:100vh;display:grid;grid-template-columns:260px 1fr}
    /* Sidebar */
    .sidebar{background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column}
    .side-head{padding:14px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border)}
    .brand{font-weight:700}
    .new-btn{background:var(--panel2);border:1px solid var(--border);padding:8px 10px;border-radius:8px;cursor:pointer}
    .list{padding:8px;overflow:auto;flex:1}
    .chat-item{padding:10px;margin:8px;border-radius:10px;background:#0f1420;border:1px solid var(--border);cursor:pointer}
    .chat-item.active{border-color:var(--accent)}
    /* Main */
    .main{display:grid;grid-template-rows:1fr auto;height:100vh}
    #chat-box{padding:20px;overflow:auto}
    .bubble{max-width:900px;padding:12px;border-radius:12px;margin:10px 0;border:1px solid var(--border);white-space:pre-wrap}
    .you{background:#0b1220}
    .ai{background:#08101a}
    pre{background:#0b0f18;padding:12px;border-radius:8px;overflow:auto;border:1px solid var(--border)}
    .copy-btn{display:inline-block;margin-top:6px;padding:6px 8px;border-radius:6px;background:#0b0f18;border:1px solid var(--border);cursor:pointer}
    /* Composer */
    .composer{padding:12px;border-top:1px solid var(--border);background:var(--panel)}
    .input-wrap{background:var(--panel2);padding:10px;border-radius:10px;border:1px solid var(--border)}
    textarea{width:100%;min-height:64px;max-height:60vh;resize:vertical;border:0;background:transparent;color:var(--text);outline:none;font:14px/1.45 monospace;white-space:pre-wrap}
    .controls{display:flex;justify-content:space-between;margin-top:8px}
    .left{display:flex;gap:8px}
    .btn{padding:8px 12px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text);cursor:pointer}
    .send{background:#163a22;border-color:#1f4d2c;color:#c6f6d5}
    .maximize.active{border-color:var(--accent)}
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="side-head">
      <div class="brand">CodeGPT</div>
      <button class="new-btn" onclick="newChat()">+ New</button>
    </div>
    <div class="list" id="chat-list"></div>
  </aside>

  <main class="main">
    <div id="chat-box"></div>

    <div class="composer">
      <div class="input-wrap" id="inputWrap">
        <textarea id="userInput" placeholder="Ask about codeâ€¦ (Shift+Enter = newline)"></textarea>
        <div class="controls">
          <div class="left">
            <button id="maximizeBtn" class="btn maximize" onclick="toggleMax()">â¤¢ Max</button>
            <button class="btn" onclick="clearComposer()">â†º Clear</button>
          </div>
          <div>
            <button class="btn send" onclick="send()">Send â–¸</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Prism (optional highlighting) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <script>
    let currentChat = null;

    // UTIL
    function escHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}
    function tsToStr(ts){return new Date(ts*1000).toLocaleString()}

    // UI helpers
    function addBubble(role, content, animate=true){
      const box = document.getElementById('chat-box');
      const wrap = document.createElement('div');
      wrap.className = 'bubble ' + (role==='user'?'you':'ai');
      // Label
      const label = document.createElement('div'); label.style.opacity=0.6; label.style.marginBottom='6px';
      label.textContent = role==='user'?'You':'AI';
      wrap.appendChild(label);

      // parse fenced code blocks
      const regex = /```(\w+)?\n([\s\S]*?)```/g;
      let lastIndex = 0, m;
      if(!animate){
        // instant render (no typewriter)
        let out = '';
        while((m = regex.exec(content)) !== null){
          out += escHtml(content.slice(lastIndex, m.index)).replace(/\n/g,'<br>');
          const lang = m[1] || '';
          const code = escHtml(m[2]);
          out += `<pre><code class="language-${lang}">${code}</code></pre>`;
          lastIndex = regex.lastIndex;
        }
        out += escHtml(content.slice(lastIndex)).replace(/\n/g,'<br>');
        wrap.innerHTML += out;
        box.appendChild(wrap);
        Prism.highlightAllUnder(wrap);
        box.scrollTop = box.scrollHeight;
        return;
      }

      // animated rendering: reveal text and insert code blocks when reached
      let cursor = 0;
      const parts = [];
      regex.lastIndex = 0;
      let start = 0;
      while((m = regex.exec(content)) !== null){
        parts.push({type:'text', text: content.slice(start, m.index)});
        parts.push({type:'code', lang: m[1] || '', code: m[2]});
        start = regex.lastIndex;
      }
      parts.push({type:'text', text: content.slice(start)});

      // sequentially type text parts and append code blocks immediately (no typing inside code)
      (async function runParts(){
        for(const p of parts){
          if(p.type==='text'){
            await typeInto(wrap, p.text);
          } else {
            // append code block instantly
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            code.className = 'language-' + (p.lang||'');
            code.textContent = p.code; // preserve indentation
            pre.appendChild(code);
            const copyBtn = document.createElement('button');
            copyBtn.className='copy-btn';
            copyBtn.textContent='ðŸ“‹ Copy';
            copyBtn.onclick = ()=>{navigator.clipboard.writeText(p.code)};
            wrap.appendChild(pre);
            wrap.appendChild(copyBtn);
            Prism.highlightAllUnder(wrap);
          }
          // keep scrolled to bottom
          box.appendChild(wrap);
          box.scrollTop = box.scrollHeight;
        }
        // ensure appended
        box.appendChild(wrap);
        box.scrollTop = box.scrollHeight;
      })();
    }

    function typeInto(container, text, speed=12){
      return new Promise(resolve=>{
        let i=0;
        const span = document.createElement('div');
        container.appendChild(span);
        function step(){
          if(i<text.length){
            span.innerHTML += escHtml(text.charAt(i)).replace(/\n/g,'<br>');
            i++;
            container.parentElement.scrollTop = container.parentElement.scrollHeight;
            setTimeout(step, speed);
          } else resolve();
        }
        step();
      });
    }

    // API calls
    async function refreshList(){
      const res = await fetch('/chats'); const data = await res.json();
      const root = document.getElementById('chat-list'); root.innerHTML='';
      data.chats.forEach(c=>{
        const el = document.createElement('div');
        el.className='chat-item';
        el.dataset.id = c.id;
        el.onclick = ()=>loadChat(c.id);
        el.innerHTML = `<div style="font-weight:600">${escHtml(c.title)}</div><div style="font-size:12px;color:${'#9aa0aa'}">${tsToStr(c.updated)}</div>`;
        if(c.id===currentChat) el.classList.add('active');
        root.appendChild(el);
      });
    }

    async function newChat(){
      const res = await fetch('/new_chat',{method:'POST'}); const d=await res.json();
      currentChat = d.chat_id;
      await refreshList();
      document.getElementById('chat-box').innerHTML='';
      document.getElementById('userInput').value='';
      document.getElementById('userInput').focus();
    }

    async function loadChat(id){
      currentChat = id;
      const res = await fetch(`/messages?chat_id=${encodeURIComponent(id)}`); const d=await res.json();
      const box = document.getElementById('chat-box'); box.innerHTML='';
      for(const m of d.messages) addBubble(m.role, m.content, false);
      await refreshList();
    }

    async function send(){
      const ta = document.getElementById('userInput');
      const msg = ta.value;
      if(!msg) return;
      addBubble('user', msg, false); ta.value='';
      // call backend
      const res = await fetch('/chat',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({chat_id:currentChat,message:msg})});
      const d = await res.json();
      if(d.chat_id) currentChat = d.chat_id;
      addBubble('ai', d.reply || '(no reply)', true);
      await refreshList();
    }

    async function clearComposer(){ document.getElementById('userInput').value=''; }
    async function toggleMax(){ const wrap = document.getElementById('inputWrap'); const btn = document.getElementById('maximizeBtn'); wrap.classList.toggle('maximized'); const active = wrap.classList.contains('maximized'); btn.classList.toggle('active', active); btn.textContent = active ? 'â¤¡ Min' : 'â¤¢ Max'; document.getElementById('userInput').focus(); }

    // reset chat messages for current chat
    async function resetThis(){
      if(!currentChat) return;
      await fetch('/reset_chat',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({chat_id:currentChat})});
      document.getElementById('chat-box').innerHTML='';
    }

    // keyboard
    document.getElementById('userInput').addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); send(); }
    });

    // init on load
    (async ()=>{
      await refreshList();
      // create a chat if none
      if(!document.querySelector('.chat-item')) await newChat();
      else {
        const first = document.querySelector('.chat-item'); if(first){ currentChat = first.dataset.id; await loadChat(currentChat); }
      }
      document.getElementById('userInput').focus();
    })();
  </script>
</body>
</html>
